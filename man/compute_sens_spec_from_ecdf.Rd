% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/roc.R
\name{compute_sens_spec_from_ecdf}
\alias{compute_sens_spec_from_ecdf}
\title{Compute sensitivity and specificity scores from (weighted) observed data}
\usage{
compute_sens_spec_from_ecdf(
  data,
  response,
  predictor,
  weights = NULL,
  direction = NULL,
  levels = NULL
)
}
\arguments{
\item{data}{a dataframe containing responses (groupings) and predictor
variable}

\item{response}{a bare column name with the group status (control vs. cases).
If the response has more than two groups, the first element of \code{levels} is
the control group and the second element of \code{levels} is the case group.}

\item{predictor}{a bare column name with the predictor to use for
classification}

\item{weights}{a bare column name for the observation weights. If \code{weights}
is set to \code{NULL} or not provided, all values receive equal weight and
conventional sensitivity and specificity scores are returned.}

\item{direction}{\code{direction} for computing case status. \code{pROC::roc()}'s
\code{direction} conventions are supported: \code{"<"} (i.e., \code{control < case}) and
\code{">"} (\code{control > case}), or \code{"auto"} to have pROC guess the direction (if
applicable). Alternatively, more verbose directions are supported:
\code{"case-low"} or \code{"control-high"} if a low score predicts case status
(\verb{case <= threshold < control}, analogous to pROC's \code{">"}) and \code{"case-high"}
or \code{"control-low"} if a high score predicts case status
(\verb{control < threshold <= case}, analogous to pROC's \code{"<"}). These
directions are translated into the pROC conventions.}

\item{levels}{two-element vector \code{c(control, case)} where \code{control} is the
value of \code{response} for the control group and \code{case} is the value of
\code{response} for the case group. The ordering matters: The first element of
the vector names the control group.}
}
\value{
A dataframe of stepwise empirical ROC coordinates computed from
(optionally weighted) data. The output includes columns for the predictor
variable, \code{.sensitivities}, \code{.specificities}, \code{.auc}, \code{.comparison},
\code{.n_controls}, \code{.n_cases}, \code{.w_controls}, \code{.w_cases}, \code{.comparison},
\code{.direction}, \code{.response}, \code{.controls}, and \code{.cases}. \code{n_} columns contain
the number of observations for that predictor value and \code{w_} contain the
total weight of the observations for that predictor value.
}
\description{
\code{pROC::roc()} does not support observation-weights when computing ROC curves.
This function fills that gap.
}
\details{
The \code{.sensitivities} and \code{.specificities} columns are calculated directly
from the (weighted) ECDFs of the controls and cases, so no call to
\code{pROC::roc()} is made.

\code{.auc} is calculated using \code{trapezoid_auc()}.

\code{c(-Inf, Inf)} are added to the \code{predictor} vector so that sensitivities and
specificities range from 0 to 1.
}
\examples{
# Simulate 3-class dataset
set.seed(100)
n <- 50
means <- c("A" = 0, "B" = 1, "C" = 2)
y <- sample(c("A", "B", "C"), n, replace = TRUE)
x <- rnorm(n, mean = means[y], sd = 1)
w <- runif(n, 0.5, 2)
df <- data.frame(y, x, w)

# Compare "A" (controls) to "C" (cases)
roc_tbl <- compute_sens_spec_from_ecdf(
  data = df,
  response = y,
  predictor = x,
  weights = w,
  direction = "control-low",
  levels = c("A", "C")
)
dplyr::glimpse(roc_tbl)

# Compare "B" (controls) to "C" (cases)
roc_tbl2 <- compute_sens_spec_from_ecdf(
  data = df,
  response = y,
  predictor = x,
  weights = w,
  direction = "control-low",
  levels = c("B", "C")
)
dplyr::glimpse(roc_tbl2)
}
\concept{roc}
