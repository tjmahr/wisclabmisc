% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/clustering.R
\name{fit_kmeans}
\alias{fit_kmeans}
\title{Run (scaled) k-means on a dataset.}
\usage{
fit_kmeans(data, k, vars, args_kmeans = list())
}
\arguments{
\item{data}{a dataframe}

\item{k}{number of clusters to create}

\item{vars}{variable selection for clustering. Select multiple variables
with \code{c()}, e.g., \code{c(x, y)}. The selection supports tidyselect semantics
\link[tidyselect:language]{tidyselect::select_helpers}, e.g., \verb{c(x, starts_with("mean_")}.}

\item{args_kmeans}{additional arguments passed to \code{stats::kmeans()}.}
}
\value{
the original \code{data} but augmented with additional columns for
clustering details. including \code{.kmeans_cluster} (cluster number of each
observation, as a factor) and \code{.kmeans_k} (selected number of clusters).

Cluster-level information is also included. For example, suppose that
we cluster using the variable \code{x}. Then the output will have a
column \code{.kmeans_x} giving the cluster mean for \code{x} and
\code{.kmeans_rank_x} giving the cluster labels reordered using the cluster
means for \code{x}. The column \code{.kmeans_sort} contains the cluster sorted
using the first principal component of the scaled variables. All columns
of cluster indices are a \code{factor()} so that they can be plotted as
discrete variables.
}
\description{
Observations are \code{scale()}-ed before clustering.
}
\details{
Note that each variable is \code{scaled()} before clustering
and then cluster means are unscaled to match the original data scale.

This function provides the original kmeans labels as \code{.kmeans_cluster} but
other alternative labeling based on different sortings of the data. These are
provided in order to deal with label-swapping in Bayesian models. See
bootstrapping example below.
}
\examples{
data_kmeans <- fit_kmeans(mtcars, 3, c(mpg, wt, hp))

library(ggplot2)
ggplot(data_kmeans) +
  aes(x = wt, y = mpg) +
  geom_point(aes(color = .kmeans_cluster))

ggplot(data_kmeans) +
  aes(x = wt, y = mpg) +
  geom_point(aes(color = .kmeans_rank_wt))

# Example of label swapping
set.seed(123)
data_boots <- lapply(
  1:10,
  function(x) {
    rows <- sample(seq_len(nrow(mtcars)), replace = TRUE)
    data <- mtcars[rows, ]
    data$.bootstrap <- x
    data
  }
) |>
  lapply(fit_kmeans, k = 3, c(mpg, wt, hp)) |>
  dplyr::bind_rows() |>
  dplyr::select(.bootstrap, dplyr::starts_with(".kmeans_")) |>
  dplyr::distinct()

# Clusters start off in random locations and move to center, so the labels
# differ between model runs and across bootstraps.
ggplot(data_boots) +
  aes(x = .kmeans_wt, y = .kmeans_mpg) +
  geom_point(aes(color = .kmeans_cluster)) +
  labs(title = "k-means centers on 10 bootstraps")

# Labels sorted using first principal component
# so the labels are more consistent.
ggplot(data_boots) +
  aes(x = .kmeans_wt, y = .kmeans_mpg) +
  geom_point(aes(color = .kmeans_sort)) +
  labs(title = "k-means centers on 10 bootstraps")
}
