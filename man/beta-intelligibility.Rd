% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/model-intelligibility.R
\name{fit_beta_gamlss}
\alias{fit_beta_gamlss}
\alias{fit_beta_gamlss_se}
\alias{predict_beta_gamlss}
\alias{optimize_beta_gamlss_slope}
\alias{uniroot_beta_gamlss}
\title{Fit a beta regression model (for intelligibility)}
\source{
Associated article: \url{https://doi.org/10.1044/2021_JSLHR-21-00142}
}
\usage{
fit_beta_gamlss(data, var_x, var_y, df_mu = 3, df_sigma = 2, control = NULL)

fit_beta_gamlss_se(
  data,
  name_x,
  name_y,
  df_mu = 3,
  df_sigma = 2,
  control = NULL
)

predict_beta_gamlss(newdata, model, centiles = c(5, 10, 50, 90, 95))

optimize_beta_gamlss_slope(
  model,
  centiles = 50,
  interval = c(30, 119),
  maximum = TRUE
)

uniroot_beta_gamlss(model, centiles = 50, targets = 0.5, interval = c(30, 119))
}
\arguments{
\item{data}{a data frame}

\item{var_x, var_y}{(unquoted) variable names giving the predictor variable
(e.g., \code{age}) and outcome variable (.e.g, \code{intelligibility}).}

\item{df_mu, df_sigma}{degrees of freedom. If \code{0} is used, the
\code{\link[splines:ns]{splines::ns()}} term is dropped from the model formula for the parameter.}

\item{control}{a \code{\link[gamlss:gamlss.control]{gamlss::gamlss.control()}} controller. Defaults to \code{NULL}
which uses default settings, except for setting trace to \code{FALSE} to silence
the output from gamlss.}

\item{name_x, name_y}{quoted variable names giving the predictor variable
(e.g., \code{"age"}) and outcome variable (.e.g, \code{"intelligibility"}). These
arguments apply to \code{fit_beta_gamlss_se()}.}

\item{newdata}{a one-column dataframe for predictions}

\item{model}{a model fitted by \code{\link[=fit_beta_gamlss]{fit_beta_gamlss()}}}

\item{centiles}{centiles to use for prediction. Defaults to
\code{c(5, 10, 50, 90, 95)} for \code{predict_beta_gamlss()}. Defaults to \code{50} for
\code{optimize_beta_gamlss_slope()} and \code{uniroot_beta_gamlss()}, although both
of these functions support multiple centile values.}

\item{interval}{for \code{optimize_beta_gamlss_slope()}, the range of \code{x} values
to optimize over. For \code{uniroot_beta_gamlss()}, the range of \code{x} values to
search for roots (target y values) in.}

\item{maximum}{for \code{optimize_beta_gamlss_slope()}, whether to find the
maximum slope (\code{TRUE}) or minimum slope (\code{FALSE}).}

\item{targets}{for \code{uniroot_beta_gamlss()}, the target y values to use as
roots. By default, .5 is used, so that \code{uniroot_beta_gamlss()} returns the
\code{x} value where the y value is .5. Multiple targets are supported.}
}
\value{
for \code{fit_beta_gamlss()} and \code{fit_beta_gamlss_se()}, a
\code{\link[=mem_gamlss]{mem_gamlss()}}-fitted model. The \code{.user} data in the model includes degrees
of freedom for each parameter and the \code{\link[splines:ns]{splines::ns()}} basis for each
parameter. For \code{predict_beta_gamlss()}, a dataframe containing the
model predictions for mu and sigma, plus columns for each centile in
\code{centiles}. For \code{optimize_beta_gamlss_slope()}, a dataframe with the
optimized \code{x} values (\code{maximum} or \code{minimum}), the gradient at that
\code{x} value (\code{objective}), and the quantile (\code{quantile}). For
\code{uniroot_beta_gamlss()}, a dataframe one row per quantile/target
combination with the results of calling \code{\link[stats:uniroot]{stats::uniroot()}}. The
\code{root} column is the \code{x} value where the \code{quantile} curve crosses the
\code{target} value.
}
\description{
The function fits the same type of GAMLSS model as used in \href{https://doi.org/10.1044/2021_JSLHR-21-00142}{Hustad and colleagues (2021)}:
A beta regression model (via \code{\link[gamlss.dist:BE]{gamlss.dist::BE()}}) with natural cubic splines
on the mean (mu) and scale (sigma). This model is fitted using this package's
\code{\link[=mem_gamlss]{mem_gamlss()}} wrapper function.
}
\details{
There are two versions of this function. The main version is
\code{fit_beta_gamlss()}, and it works with unquoted column names (e.g.,
\code{age}). The alternative version is \code{fit_beta_gamlss_se()}; the final
"se" stands for "Standard Evaluation". This designation means that the
variable names must be given as strings (so, the quoted \code{"age"} instead of
bare name \code{age}). This alternative version is necessary when we fit several
models using parallel computing with \code{\link[furrr:future_map]{furrr::future_map()}} (as when using
bootstrap resampling).

\code{\link[=predict_centiles]{predict_centiles()}} will work with this function, but it will likely throw a
warning message. Therefore, \code{predict_beta_gamlss()} provides an alternative
way to compute centiles from the model. This function manually computes the
centiles instead of relying on \code{\link[gamlss:centiles]{gamlss::centiles()}}. The main difference is
that new \emph{x} values go through \code{\link[splines:predict.bs]{splines::predict.ns()}} and then these are
multiplied by model coefficients.

\code{optimize_beta_gamlss_slope()} computes the point (i.e., age) and rate of
steepest growth for different quantiles. This function wraps over the
following process:
\itemize{
\item an internal prediction function computes a quantile at some \code{x} from model
coefficients and spline bases.
\item another internal function uses \code{numDeriv::grad()} to get the gradient
of this prediction function for \code{x}.
\item \code{optimize_beta_gamlss_slope()} uses \code{stats::optimize()} on the gradient
function to find the \code{x} with the maximum or minimum slope.
}

\code{uniroot_beta_gamlss()} also uses this internal prediction function to find
when a quantile growth curve crosses a given value. \code{\link[stats:uniroot]{stats::uniroot()}} finds
where a function crosses 0 (a root). If we modify our prediction function to
always subtract .5 at the end, then the root for this prediction function
would be the x value where the predicted value crosses .5. That's the idea
behind how \code{uniroot_beta_gamlss()} works. In our work, we would use this
approach to find, say, the age (root) when children in the 10th percentile
(\code{centiles}) cross 50\% intelligibility (\code{targets}).
\subsection{GAMLSS does beta regression differently}{

This part is a brief note that GAMLSS uses a different parameterization of the
beta distribution for its beta family than other packages.

The canonical parameterization of the beta distribution uses shape parameters
\eqn{\alpha} and \eqn{\beta} and the probability density function:

\deqn{f(y;\alpha,\beta) = \frac{1}{B(\alpha,\beta)} y^{\alpha-1}(1-y)^{\beta-1}}

where \eqn{B} is the \href{https://en.wikipedia.org/wiki/Beta_function}{beta function}.

For beta regression, the distribution is reparameterized so that there is a
mean probability \eqn{\mu} and some other parameter that represents the
spread around that mean. In GAMLSS (\code{\link[gamlss.dist:BE]{gamlss.dist::BE()}}), they use a scale
parameter \eqn{\sigma} (larger values mean more spread around mean).
Everywhere else—\code{\link[betareg:betareg]{betareg::betareg()}} and \code{\link[rstanarm:stan_betareg]{rstanarm::stan_betareg()}} in
\code{vignette("betareg", "betareg")}, \code{\link[brms:brmsfamily]{brms::Beta()}} in
\code{vignette("brms_families", "brms")}, \code{\link[mgcv:Beta]{mgcv::betar()}}—it's a precision
parameter \eqn{\phi} (larger values mean more precision, less spread around
mean). Here is a comparison:

\deqn{
 \text{betareg, brms, mgcv, etc.} \\
 \mu              = \alpha / (\alpha + \beta) \\
 \phi             = \alpha + b \\
 \textsf{E}(y)    = \mu \\
 \textsf{VAR}(y)  = \mu(1-\mu)/(1 + \phi) \\
}

\deqn{
 \text{GAMLSS} \\
 \mu             = \alpha / (\alpha + \beta) \\
 \sigma          = (1 / (\alpha + \beta + 1))^.5 \\
 \textsf{E}(y)   = \mu \\
 \textsf{VAR}(y) = \mu(1-\mu)\sigma^2
}
}
}
\examples{
data_fake_intelligibility

m <- fit_beta_gamlss(
  data_fake_intelligibility,
  age_months,
  intelligibility
)

# using "qr" in summary() just to suppress a warning message
summary(m, type = "qr")

# Alternative interface
d <- data_fake_intelligibility
m2 <- fit_beta_gamlss_se(
  data = d,
  name_x = "age_months",
  name_y = "intelligibility"
)
coef(m2) == coef(m)

# how to use control to change gamlss() behavior
m_traced <- fit_beta_gamlss(
  data_fake_intelligibility,
  age_months,
  intelligibility,
  control = gamlss::gamlss.control(n.cyc = 15, trace = TRUE)
)

# The `.user` space includes the spline bases, so that we can make accurate
# predictions of new xs.
names(m$.user)

# predict logit(mean) at 55 months:
logit_mean_55 <- cbind(1, predict(m$.user$basis_mu, 55)) \%*\% coef(m)
logit_mean_55
stats::plogis(logit_mean_55)

# But predict_gen_gamma_gamlss() does this work for us and also provides
# centiles
new_ages <- data.frame(age_months = 48:71)
centiles <- predict_beta_gamlss(new_ages, m)
centiles

# Confirm that the manual prediction matches the automatic one
centiles[centiles$age_months == 55, "mu"]
stats::plogis(logit_mean_55)

if(requireNamespace("ggplot2", quietly = TRUE)) {
  library(ggplot2)
  ggplot(pivot_centiles_longer(centiles)) +
    aes(x = age_months, y = .value) +
    geom_line(aes(group = .centile, color = .centile_pair)) +
    geom_point(
      aes(y = intelligibility),
      data = subset(
        data_fake_intelligibility,
        48 <= age_months & age_months <= 71
      )
    )
}

# Age of steepest growth for each centile
optimize_beta_gamlss_slope(
  model = m,
  centiles = c(5, 10, 50, 90),
  interval = range(data_fake_intelligibility$age_months)
)

# Manual approach: Make fine grid of predictions and find largest jump
centiles_grid <- predict_beta_gamlss(
  newdata = data.frame(age_months = seq(28, 95, length.out = 1000)),
  model = m
)
centiles_grid[which.max(diff(centiles_grid$c5)), "age_months"]

# When do children in different centiles reach 50\%, 70\% intelligibility?
uniroot_beta_gamlss(
  model = m,
  centiles = c(5, 10, 50),
  targets = c(.5, .7)
)
}
\concept{models}
