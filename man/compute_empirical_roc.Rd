% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/roc.R
\name{compute_empirical_roc}
\alias{compute_empirical_roc}
\title{Create an ROC curve from observed data}
\usage{
compute_empirical_roc(
  data,
  response,
  predictor,
  direction = "auto",
  best_weights = c(1, 0.5),
  ...
)
}
\arguments{
\item{data}{a dataframe containing responses (groupings) and predictor
variable}

\item{response}{a bare column name with the group status (control vs. cases)}

\item{predictor}{a bare column name with the predictor to use for
classification}

\item{direction}{\code{direction} to set for the for \code{pROC::roc()}. Defaults to
\code{"auto"}.}

\item{best_weights}{weights for computing the best ROC curve points. Defaults
to \code{c(1, .5)}, which are the defaults used by \code{pROC::coords()}.}

\item{...}{additional arguments passed to \code{pROC::roc()}.}
}
\value{
a new dataframe of ROC coordinates is returned with columns for the
predictor variable, \code{.sensitivities}, \code{.specificities}, \code{.auc},
\code{.direction}, \code{.controls}, \code{.cases}, \code{.is_best_youden} and
\code{.is_best_closest_topleft}.
}
\description{
Create an ROC curve from observed data
}
\examples{
set.seed(100)
x1 <- rnorm(100, 4, 1)
x2 <- rnorm(100, 2, .5)
both <- c(x1, x2)
steps <- seq(min(both), max(both), length.out = 200)
d1 <- dnorm(steps, mean(x1), sd(x1))
d2 <- dnorm(steps, mean(x2), sd(x2))
data <- tibble::tibble(
  y = steps,
  d1 = d1,
  d2 = d2,
  outcome = rbinom(200, 1, prob = 1 - (d1 / (d1 + d2))),
  group = ifelse(outcome, "case", "control")
)

# get an ROC on the fake data
compute_empirical_roc(data, outcome, y)
# this guess the cases and controls from the group name and gets it wrong
compute_empirical_roc(data, group, y)
# better
compute_empirical_roc(data, group, y, levels = c("control", "case"))
}
\concept{roc}
